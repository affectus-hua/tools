[{"id":"409bcac5.3ee164","type":"subflow","name":"Knowledge Base","info":"Inputs:\n Required: msg.query :\n  The Query itself (String or JSON (created from SPARQL.js Parser ONLY!))\n Optional (for query string): msg.mode :\n  FORCE 'select' or 'update' (or 'delete') for SPARQL 1.1\n  Best in Auto Mode...\n Optional: msg.endpoint : Alternate endpoint\nSparql errors are filtered before query is sent to KB.\nOutputs:\n For select: Array of objects\n    Each has key value pairs. Key is variable name\n For update: msg.payload[0] is 'Success' or 'Failure'\n    msg.payload[1] is the message.\n    The rest is up to the server.\n\nMore on:\nSPARQL.js: https://github.com/RubenVerborgh/SPARQL.js/\n ","in":[{"x":60,"y":40,"wires":[{"id":"550a1fef.075cd"}]}],"out":[{"x":1240,"y":440,"wires":[{"id":"abbbb90f.f96d78","port":0},{"id":"9b6037e7.7406b8","port":2},{"id":"e7ffadc6.8a0b","port":0},{"id":"5ca3ebc9.633ff4","port":0},{"id":"e7e236a5.bff4c8","port":2},{"id":"d9f60fa2.0d7b3","port":0}]}]},{"id":"d3ac1de2.7f249","type":"comment","z":"409bcac5.3ee164","name":"Knowledge Base Connector (Final)","info":"","x":580,"y":40,"wires":[]},{"id":"c13d5d1a.c3e37","type":"function","z":"409bcac5.3ee164","name":"SPARQL_Request","func":"//Setup\nconst fetch = context.global.fetch;\nvar SparqlHttp = context.global.sparqlhttp;\nSparqlHttp.fetch = fetch;\n \n//Which endpoint to query, is in msg.endpoint\nvar endpoint = new SparqlHttp({endpointUrl: msg.endpoint});\n\nvar result = null;\n//The SPARQL query itself is in msg.query\n//Run query with promises\nendpoint.selectQuery(msg.query).then(function (res) {\n    return res.text();\n    //Result body of the query\n}).then(function (body) {\n    console.log(\"SPARQL Request Completed!\");\n    // parse the body\n    result = JSON.parse(body);\n    msg.payload = result;\n    node.send(msg);\n//Necessary to catch the error...\n}).catch(function (err) {\n  console.error(err);\n});\n\n\n\n\n","outputs":1,"noerr":0,"x":650,"y":140,"wires":[["abbbb90f.f96d78"]]},{"id":"9ab1ec65.c10c8","type":"function","z":"409bcac5.3ee164","name":"SPARQL_Update","func":"//Setup\nconst fetch = context.global.fetch;\nvar SparqlHttp = context.global.sparqlhttp;\nSparqlHttp.fetch = fetch;\n \n//Which endpoint to query, is in msg.endpoint\nvar endpoint = new SparqlHttp({updateUrl: msg.endpoint});\n\nvar result = null;\n//The SPARQL query itself is in msg.query\n//Run query with promises\nendpoint.updateQuery(msg.query).then(function (res) {\n    return res.text();\n    //Result body of the query\n}).then(function (body) {\n    console.log(\"SPARQL Request Completed!\\n\" + body );\n    msg.payload = body;\n    node.send(msg);\n//Necessary to catch the error...\n}).catch(function (err) {\n  console.error(err);\n});\n","outputs":1,"noerr":0,"x":650,"y":200,"wires":[["e7e236a5.bff4c8"]]},{"id":"abbbb90f.f96d78","type":"function","z":"409bcac5.3ee164","name":"Process Response","func":"//Static Prefixes if prefixes not defined in query.\nconst prefixes = {\"rdf\":\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n\"rdfs\":\"http://www.w3.org/2000/01/rdf-schema#\",\n\"owl\":\"http://www.w3.org/2002/07/owl#\",\n\"\":\"http://www.hua.gr/affectus#\",\n\"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n\"time\":\"http://www.w3.org/2006/time#\",\n\"geojson\":\"https://purl.org/geojson/vocab#\",\n\"#\":\"http://server/unset-base/#\"\n};\n\n//Utility\nconst merge_prefixes = (obj1,obj2) => {\n    var obj3 = {};\n    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\n    for (attrname in obj2) { obj3[attrname] = obj2[attrname]; }\n    return obj3;\n};\n\nvar allPrefixes = merge_prefixes(prefixes,msg.prefixes);\nvar results = [];\nvar variables = msg.payload.head.vars;\n\n//Utility\nconst isDefined = (variable) => {\n    if (typeof variable === 'undefined' || variable === null || variable === \"\") {\n        return false;\n    } else return true;\n};\n\n//Utility: Fix/Remove the prefixes\nconst prefixFilter = (item) =>{\n    item = item + \"\";\n    pieces = item.split('#');//All standard prefixes end with #\n    for (var prefix in allPrefixes) {\n        if(item.includes(allPrefixes[prefix])) {\n            if (prefix === '' || prefix == '#'){\n                item = \"\";\n            }else item = prefix + \":\";\n            item = item + pieces[pieces.length - 1];\n            break;\n        }\n    }\n    return item;\n};\n\n//Create a clean object.\nconst fixObj = (item, index, arr) => {\n    obj = {};\n    for (i = 0 ; i< variables.length;i++){\n        myVar = variables[i];\n        if(isDefined(item[myVar])){\n            obj[myVar] = prefixFilter(item[myVar].value);\n        }\n    }\n    arr[index] = obj;\n};\n\nmsg.payload = msg.payload.results.bindings;\nmsg.payload.forEach(fixObj);\n\n\nreturn msg;","outputs":1,"noerr":0,"x":1050,"y":160,"wires":[[]]},{"id":"550a1fef.075cd","type":"function","z":"409bcac5.3ee164","name":"Prepare Request","func":"//Utility\nconst isDefined = (variable) => {\n    if (typeof variable === 'undefined' || variable === null || variable === \"\") {\n        return false;\n    } else return true;\n};\n\n//Base query for SPARQL.JS\n//Static Prefixes\nconst prefixes = {\"rdf\":\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n\"rdfs\":\"http://www.w3.org/2000/01/rdf-schema#\",\n\"owl\":\"http://www.w3.org/2002/07/owl#\",\n\"\":\"http://www.hua.gr/affectus#\",\n\"xsd\":\"http://www.w3.org/2001/XMLSchema#\",\n\"time\":\"http://www.w3.org/2006/time#\",\n\"geojson\":\"https://purl.org/geojson/vocab#\",\n\"i\": \"http://server/unset-base/#\"\n};\n//Utility\nconst merge_prefixes = (obj1,obj2) => {\n    var obj3 = {};\n    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\n    for (attrname in obj2) { obj3[attrname] = obj2[attrname]; }\n    return obj3;\n};\n//Static & mutable for select queries\nconst queryType = \"SELECT\";\n\n//check if query isn't set up\nif(!isDefined(msg.query) ){\n    console.error(\"DEFINE SPARQL QUERY!!!\");\n    msg.error = \"No SPARQL query\";\n    return msg;\n}\nvar type = \"\";\nmsg.prefixes = {};\nconst generator = new context.global.sparqljs.Generator();\n\n//Generate SPARQL from JSON and error filtering.\n//Usable only on queries parsed outside the connector.\nif(typeof msg.query === 'object'){//Input: JSON PARAMETERS.\n    msg.query[\"prefixes\"] = merge_prefixes(prefixes, msg.query.prefixes);\n    for(var prefix in msg.query.prefixes){\n        if(!isDefined(prefixes[prefix])){\n            msg.prefixes[prefix] = msg.query.prefixes[prefix];\n        }\n    }//Fix prefixes!\n    //In msg.query...\n    if(msg.query.type==\"query\"){\n        type = \"query\";\n        //...required Input: type:\"query\", variables:[\"?var0\",...], where[{},{},...]\n        \n    }else if(msg.query.type == \"update\"){\n        type = \"update\";\n        //...required Input: type:\"update\", updates:[{},{}]\n        \n    }\n    msg.query = generator.stringify(msg.query);\n}else if (typeof msg.query  === 'string'){//Input: READY SPARQL QUERY.\n    const prefs = `PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\nPREFIX : <http://www.hua.gr/affectus#> \nPREFIX time: <http://www.w3.org/2006/time#>\nPREFIX geojson: <https://purl.org/geojson/vocab#>\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\nPREFIX i: <http://server/unset-base/#>`;\n    const parser = new context.global.sparqljs.Parser();//Parse input query\n    msg.query = prefs + msg.query;\n    query = parser.parse(msg.query);\n    if(msg.mode === null || msg.mode === undefined){//Find mode.\n        type = query.type;\n    }\n    for(var prefix in query.prefixes){\n        if(!isDefined(prefixes[prefix])){\n            msg.prefixes[prefix] = query.prefixes[prefix];\n        }\n    }\n    query[\"prefixes\"] = merge_prefixes(prefixes, query.prefixes);\n    msg.query = generator.stringify(query);\n}else{\n    console.error(\"WRONG TYPE FOR SPARQL QUERY!!!\");\n    msg.error = \"Malformed query\";\n    return msg;\n}\n\n//SET MODE!\nif(type == \"query\"){\n    msg.mode = 'select';\n}else if(type == \"update\"){\n    msg.mode = 'update';\n}else{\n    console.error(\"WRONG query Type FOR SPARQL!!!\");\n    msg.error = \"Invalid query Type\";\n    return msg; \n}\n\n//SET SPARQL ENDPOINT\nif(msg.mode == 'select' || msg.mode == 'update'){\n    //check if endpoint is set to a different one\n    if(msg.endpoint === null || msg.endpoint === undefined ){\n        if(msg.mode=='select'){\n            msg.endpoint = \"http://localhost:3030/affectus/sparql\";\n        }else if (msg.mode=='update'){\n            msg.endpoint = \"http://localhost:3030/affectus/update\";\n        }\n    }\n}\nelse{\n    console.error(\"INVALID SPARQL 1.1 Mode!!!\");\n    msg.error = \"SPARQL mode not well defined!\";\n    return msg;\n}\n\nreturn msg;","outputs":1,"noerr":0,"x":250,"y":120,"wires":[["9b6037e7.7406b8"]]},{"id":"9b6037e7.7406b8","type":"switch","z":"409bcac5.3ee164","name":"select or update?","property":"mode","propertyType":"msg","rules":[{"t":"eq","v":"select","vt":"str"},{"t":"eq","v":"update","vt":"str"},{"t":"else"}],"checkall":"true","outputs":3,"x":450,"y":200,"wires":[["c13d5d1a.c3e37"],["9ab1ec65.c10c8"],[]]},{"id":"116ee568.212c8b","type":"catch","z":"409bcac5.3ee164","name":"","scope":null,"x":200,"y":180,"wires":[["7e6a4310.745c8c","d9f60fa2.0d7b3"]]},{"id":"7e6a4310.745c8c","type":"debug","z":"409bcac5.3ee164","name":"","active":true,"console":"false","complete":"true","x":430,"y":280,"wires":[]},{"id":"d9f60fa2.0d7b3","type":"function","z":"409bcac5.3ee164","name":"","func":"console.error(msg.error.message);\nreturn msg;","outputs":1,"noerr":0,"x":430,"y":320,"wires":[[]]},{"id":"e7ffadc6.8a0b","type":"html","z":"409bcac5.3ee164","name":"parse response","tag":"h1,p","ret":"text","as":"single","x":1060,"y":200,"wires":[[]]},{"id":"e7e236a5.bff4c8","type":"switch","z":"409bcac5.3ee164","name":"","property":"payload","propertyType":"msg","rules":[{"t":"cont","v":"<html>","vt":"str"},{"t":"cont","v":"Error","vt":"str"},{"t":"else"}],"checkall":"true","outputs":3,"x":810,"y":200,"wires":[["e7ffadc6.8a0b"],["5ca3ebc9.633ff4"],[]]},{"id":"5ca3ebc9.633ff4","type":"function","z":"409bcac5.3ee164","name":"process response","func":"msg.payload = msg.payload.split(\"\\n\").filter( word => word!==\"\");\nreturn msg;","outputs":1,"noerr":0,"x":1050,"y":240,"wires":[[]]},{"id":"22892a7a.4ccd36","type":"subflow:409bcac5.3ee164","z":"e76f8aae.095048","name":"","x":750,"y":460,"wires":[["55e7ed2a.156464"]]}]